# 01. 객체, 설계

### 1. 티켓 판매 애플리케이션 구현하기

추첨을 통해 선정된 관람객에게 무료로 관람할 수 있는 초대장 발송

- 이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후 입장
- 이벤트에 당첨되지 않은 관람객은 티켓을 구매한 후 입장

### 2. 무엇이 문제인가

로버트 마틴의 <클린 소프트웨어>에서 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.  
모듈이란 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미한다.

1. 제대로 실행되어야 한다.
2. 변경이 용이해야 한다.
3. 이해하기 쉬워야 한다.

1장의 1까지의 코드는 1번은 만족하지만 2, 3번은 만족시키지 못한다.

#### 예상을 빗나가는 코드

##### 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재로 표현되어 있다.

- 관람객이 직접 자신의 가방에서 돈을 직접 꺼내 판매원에게 지불한다.
- 판매원은 매표소에 있는 티켓을 직접 꺼내 관람객에게 건내고 관람객에게 직접 돈을 받아 매표소에 보관한다.  

##### 코드를 이해하기 위해서 여러가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다.

- `Theater`의 enter 메소드를 이해하기 위해서는 Audience가 Bag을 가지고 있고, Bag 안에는 현금과 티켓이 들어있으며 TicketSeller가 TicketOffice에서 티켓을 판매하고, TicketOffice 안에 돈과 티켓이 보관되어 있다는 모든 사실을 동시에 기억하고 있어야 한다.
- 하나의 클래스나 메소드에서 너무 많은 세부사항을 다루기 때문에 작성하는 사람 뿐 아니라 읽고 이해해야 하는 사람 모두에게 큰 부담을 준다.
- 가장 심각한 문제는 Audience와 TicketSeller를 변경할 경우 `Theater`도 함께 변경해야 한다.

#### 변경에 취약한 코드

##### 객체 사이의 의존성(`dependency`)의 문제

- 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다.  
- 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하자  
- 객체 사이의 의존성이 과한 경우 결합도(`coupling`)가 높다고 한다.
- 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만들어야 한다.

### 3. 설계 개선하기

관람객과 판매원이 자신의 일을 스스로 처리해야 한다.  
`Theater`가 Audience와 TicketSeller에 관해 너무 세세한 부분까지 알지 못하도록 정보를 차단한다.
- 관람객이 가방을 가지고 있다는 사실과 판매원이 매표소에서 티켓을 판매한다는 사실을 Theater가 알아야 할 필요가 없다.
- 관람객과 판매원을 자율적인 존재로 만들자

#### 자율성을 높이자

`Theater`의 enter 메소드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨긴다.  
ticketOffice에 대한 접근은 오직 TicketSeller 안에만 존재하게 된다.  
- 이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화(`encapsulation`)라고 부른다.  
- 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다.

`Theater`는 오직 TicketSeller의 인터페이스(`interface`)에만 의존한다.  
TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현(`implementation`)의 영역에 속한다.

객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.

Audience와 TicketSeller가 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임지고 해결한다.
`자율적인 존재`가 되었다.

#### 무엇이 개선됐는가

자신이 가지고 있는 소지품을 스스로 관리한다.  
내부 구현을 변경하더라도 Theater를 함께 변경할 필요가 없어졌다.  
변경 용이성의 측면에서도 확실히 개선됐다고 말할 수 있다.

#### 어떻게 한 것인가

자기 자신의 문제를 스스로 해결하도록 코드를 변경했다.  
수정한 후의 Theater는 Audience나 TicketSeller의 내부에 직접 접근하지 않는다.  
Audience는 Bag을 제어하는 작업을 스스로 처리하며 외부의 누군가에게 자신의 가방을 열어보도록 허용하지 않는다.  
TicketSeller 역시 매표소의 보관된 티켓을 직접 판매하도록 바뀌었다.  

`객체의 자율성`을 높이는 방향으로 설계를 개선했다.  
그 결과, 이해하기 쉽고 유연한 설계를 얻을 수 있었다.

#### 캡슐화와 응집도

객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만든다.  
밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도(`cohesion`)가 높다고 말한다.  
자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.  

응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다.  
객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다.  
외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길이다.

#### 절차지향과 객체지향

프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 부른다.  

변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다.  

자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 Audience와 TicketSeller로 이동시키는 것이다.

이처럼 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식을 객체지향 프로그래밍이라고 부른다.

훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성으르 적절히 관리함으로써 결합도를 낮추는 것이다.

#### 책임의 이동

책임을 기능을 가리키는 객체지향 세계의 용어로 생각해도 무방하다.

절차적 프로그래밍에서는 책임이 Theater에 집중되어 있다.

객체지향 설계에서는 여러 객체에 걸쳐 분산되어 있다.

설계를 어렵게 만드는 것은 `의존성`이다. 해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 `결합도`를 낮추는 것이다.  
예제에서는 Theater가 몰라도 되는 세부사항을 Audience와 TicketSeller 내부로 감춰 `캡슐화`하는 것이다.  
불필요한 세부사항을 객체 내부로 캡슐화하는 것은 객체의 `자율성`을 높이고 `응집도` 높은 객체들의 공동체를 창조할 수 있게 한다.

#### 더 개선할 수 있다

Bag은 과거의 Audience처럼 스스로 자신을 책임지지 않고 Audience에 의해 끌려다니는 수동적인 존재다.

Bag을 자율적인 존재로 바꿔보자. Bag의 내부 상태에 접근하는 모든 로직을 Bag 안으로 캡슐화해서 결합도를 낮추면 된다.

외부에서 사용되지 않는 메소드들의 가시성을 private으로 변경했다.

TicketSeller 역시 TicketOffice의 자율권을 침해한다.  

TicketOffice의 자율권을 찾아주자. TicketOffice에 sellTicketTo 메소드를 추가하고 TicketSeller의 sellTo 메소드의 내부 코드를 이 메소드로 옮기자.

이제 TicketSeller가 TicketOffice의 구현이 아닌 인터페이스에만 의존하게 되었다.

그렇지만 변경 전에는 존재하지 않았던 TicketOffice와 Audience 사이에 새로운 의존성이 추가되었다.

`트레이드오프`의 시점이 왔다. 설계는 균형의 예술이다. 훌륭한 설계는 적절한 트레이드오프의 결과물이라는 사실을 명심하라.  
이러한 트레이드오프 과정이 설계를 어려우면서도 흥미진진한 작업으로 만드는 것이다.

#### 그래, 거짓말이다!

현실에서는 수동적인 존재라고 하더라도 일단 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.  
이렇게 소프트웨어 객체를 설계하는 원칙을 가리켜 의인화(`anthropomorphism`)라고 부른다.

### 4. 객체지향 설계

#### 설계가 왜 필요한가

설계를 구현과 떨어트려서 이야기하는 것은 불가능하다.  
설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다.  
설계는 코드 작성의 일부이며 코드를 작성하지 않고서는 검증할 수 없다.  
좋은 설계란 무엇인가? 우리가 짜는 프로그램은 두 가지 요구사항을 만족시켜야 한다.

- 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 한다.
- 내일 쉽게 변경할 수 있는 코드를 짜야 한다.

변경을 수용할 수 있는 설계가 중요한 이유는 요구사항이 항상 변경되기 때문이다.
  
#### 객체지향 설계

우리가 진정으로 원하는 것은 변경에 유연하게 대응할 수 있는 코드다.  
변경 가능한 코드란 이해하기 쉬운 코드다.

객체지향 패러다임은 우리가 세상을 바라보는 방식대로 코드를 작성할 수 있게 돕는다.
객체 역시 자신의 데이터를 스스로 책임지는 자율적인 존재다.

객체지향의 세계에서 애플리케이션은 객체들로 구성되며 애플리케이션의 기능은 객체들 간의 상호작용을 통해 구현된다.

훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다.
객체가 실행되는 주변 환경에 강하게 결합될수록 변경하기 어려워진다.

협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것이 진정한 객체지향 설계로 나아가는 길이다.

